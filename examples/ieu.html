<!DOCTYPE html>
<html>
	<head>
		<style>
			@keyframes foo {
				0% { background-color: lavender; }
				20% { background-color: navajowhite; }
				40% { background-color: palegoldenrod; }
				60% { background-color: snow; }
				80% { background-color:  bisque; }
				100% { background-color: linen; }
			}
			body {
				margin: 0;
				padding: 0;

				display: flex;

				flex-wrap: nowrap;
				justify-content: center;
				align-items: center;

				background-color:  lavender;
				animation-name: foo;
				animation-duration: 120s;

			}
			div.pad {
				flex: 0;
			}
			@keyframes bar {
				from { filter: grayscale(80%); }
				to { filter: inherit; }
			}

			svg {
				margin-top: 2em;
				height: 500px;
				width: 90%;
				background-color: rgba(255, 255, 255, 0.25);

				filter: grayscale(80%);
				animation-name: bar;
				animation-duration: 37s;
			}
			.axis > line {
				stroke: rgba(20, 20, 20, 0.35);
				stroke-width: 1;
			}

			.points > circle {
				transition: cx 60s;
				stroke-width: 0;
			}
			.lastPointLabels > text {
				stroke-width: 0;
				fill: green;
				font-size: .25em;
				transform: translateY(-.5em);
			}

			.points .A { fill: red; }
			.points .B { fill: green; }
			.points .C { fill: purple; }

			.lastPointLabels .A { fill: firebrick; }
			.lastPointLabels .B { fill: olivedrab; }
			.lastPointLabels .C { fill: indigo; }
		</style>

		<script src="https://unpkg.com/mqtt/dist/mqtt.min.js" async="true" onload="mqttloaded(this);"></script>
		<script>
			function zip(a,b){ return a.map((e,i) => [e, b[i]]); }
		</script>
		<script type="text/javascript">
			const HTML5NS = '';
			const SVGNS = 'http://www.w3.org/2000/svg';
		</script>
		<script>
			class Bucket extends EventTarget {
				static conjure() { return new Bucket(); }

				static from(source) {
					const b = new Bucket();
					source.addEventListener('add', event => { b.add(event.detail.slot, event.detail); })
					return b;
				}

				constructor() {
					super();
					this._bucket = []; // todo could be a {}
					this._total = 0;
					this._sum = 0;
				}

				add(slot, detail) {
					if(this._bucket[slot] === undefined) { this._bucket[slot] = []; }
					this._bucket[slot].push(detail.sum); // todo { value: value, insertedAt: new Date() }

					// update
					this._total += detail.total;
					this._sum += detail.sum;

					// fake async
					const event = new CustomEvent('add', { detail: { slot: 0, total: this._total, sum: this._sum }});
					const preventD = this.dispatchEvent(event);
				}


			}

			const Bs = Bucket.conjure(60);
			const Bm = Bucket.from(Bs, 60);
			const Bh = Bucket.from(Bm, 24);

			Bs.add(2, { total: 1, sum: 37 });
			Bs.add(3, { total: 1, sum: 42 });
		</script>
		<script type="text/javascript">

			class Graph {
				static stable(state) {
					return true;
				}
				static add(state, timestamp, value) {

				}
			}
		</script>
		<script>
			const state = {
				duration: 'hour',
				samples: []
			};

			var min;
			var max;

			function scale(value, from, to) {
				if(!isFinite(from[0])) throw Error('from 0')
				if(!isFinite(from[1])) throw Error('from 1')
				if(!isFinite(to[0])) throw Error('to 0')
				if(!isFinite(to[1])) throw Error('to 1')

				const fromMag = from[1] - from[0];
				const toMag = to[1] - to[0];
				const ratio = toMag / (fromMag * 1.0);

				return (value - from[0]) * ratio + to[0];
			}

			function add(value, group) {

				if(min == undefined) { min = value; }
				if(max == undefined) { max = value; }
				min = Math.min(min, value);
				max = Math.max(max, value);
				if(max - min < 2) { max += 0.5;  min -= 0.5; }

				let y = scale(value, [min, max], [95, 5]);
				if(!isFinite(y)) throw Error('y not finite');

				const points = svg.querySelector('.points');
				const groupText = svg.querySelector('.lastPointLabels' + ' .' + group);
				groupText.innerHTML = '' + Math.trunc(value * 1000) / 1000.0 + '&deg;C';
				groupText.setAttribute('x', 180);
				groupText.setAttribute('y', y);



				const point = document.createElementNS(SVGNS, 'circle');
				point.setAttribute('class', group);
				point.setAttribute('cx', 195);
				point.setAttribute('cy', y);
				point.setAttribute('r', 1);
				point.setAttribute('transition', 'cx 60s');
				points.appendChild(point);

				setTimeout(() => { point.setAttribute('cx', 5); }, 100);
				setTimeout(() => { points.removeChild(point); }, 58 * 1000);
			}


			function setup() {
				// snap global element
				svg = document.querySelector('SVG');
				// setupEffectorCallback(state);
			}

			function update(state) {


			}

			function step(timestamp) {
				//console.log('step?');
				if(Graph.stable(state)) {
					//console.log('no need');
					return;
				}

				update(state);

				if(!Graph.stable(state)){ window.requestAnimationFrame(step); }
			}

			const availC = ['A', 'B', 'C'];
			const usedC = {};
			function groupForName(result) {
				const group = result.signature ? result.signature : (result.name ? result.name : 'unknown');
				if(usedC[group] !== undefined) { return usedC[group]; }

				const nextC = availC.shift();
				usedC[group] = nextC;

				const pls = svg.querySelector('.lastPointLabels');
				const text = document.createElementNS(SVGNS, 'text');
				text.setAttribute('class', nextC);
				text.appendChild(document.createTextNode('-'));
				pls.appendChild(text);

				return nextC;
			}

			const blob = [];
			function handleIUE(client, result) {
				//console.log(result);
				add(result.tempature.C, groupForName(result));

				//
				const timestamp = (new Date(result.time)).getTime();
				const now = Date.now();
				if(timestamp > now) { throw Error('great scotts. heavy doc'); }
				const durationMs = 1000 * 60 * 1;
				const endtimestamp = now - durationMs;
				if(timestamp < endtimestamp) { console.log('to little too late'); return; }



				//blob[]
			}

			function mqttloaded(script) {
				console.log('mqtt loaded');
				const client = mqtt.connect('ws://192.168.1.14:1884', { reconnectPeriod: 30 * 1000});
				client.on('connect', () => { console.log('mqtt connected'); client.subscribe('boschieu/#') });
				client.on('disconnect', () => { console.log('mqtt disconnected'); });
				client.on('message', (topic, message) => {
					try {
						const json = JSON.parse(message);
						handleIUE(client, json);
					}
					catch(e) {
						console.log('failed to parse message', e);
					}
				});

			}

			window.addEventListener('load', event => {
				setup();
				// and kick off natural animation
				window.requestAnimationFrame(step);
			});
		</script>
	</head>
	<body>
			<div class="pad"></div>
			<svg viewBox="0 0 200 100" preserveAspectRatio="xMidYMid meet">
				<defs>
					<marker id='head' orient="auto"
						markerWidth="4" markerHeight="4"
						refX='4' refY='2'>
						<!-- triangle pointing right (+x) -->
						<path d='M0,0 V4 L2,2 Z' class="marker"/>
					</marker>
					<marker id="marker-arrow" markerWidth="12" markerHeight="12" refx="6" refy="4" orient="auto">
						<path d="M 1 1 7 4 1 7 Z" class="marker"/>
					</marker>
				</defs>
				<g class="lastPointLabels">
				</g>
				<g class="points">
				</g>
				<g class="axis">
					<line class="time" x1="5.5" y1="95" x2="195" y2="95" />
					<line class="value" x1="5" y1="5" x2="5" y2="95.5" />
				</g>
			</svg>
			<div class="pad"></div>
	</body>
</html>
